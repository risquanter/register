# ADR-009: Compositional Risk Aggregation via Identity

**Status:** Accepted  
**Date:** 2026-01-17  
**Tags:** architecture, domain-model, zio-prelude, aggregation, monoid

---

## Context

The risk register models a **tree of risks** where:
- **Leaf nodes** (`RiskLeaf`) define distribution parameters (probability, loss bounds)
- **Branch nodes** (`RiskPortfolio`) aggregate children but have no distribution of their own

After Monte Carlo simulation, every node needs a **loss distribution** for LEC visualization—including aggregates. The challenge is: how do mid-level nodes acquire distributions when only leaves have parameters?

---

## Decision

### Uniform Result Type via `RiskResult`

All nodes—leaf and branch—share the same result type:

```scala
case class RiskResult(
  nodeId: NodeId,
  outcomes: Map[TrialId, Loss],  // Sparse: only non-zero trials
  provenances: List[NodeProvenance] = Nil
) extends LossDistribution with LECCurve
```

| Node Type | How `RiskResult` is produced |
|-----------|------------------------------|
| `RiskLeaf` | Monte Carlo sampling from metalog distribution |
| `RiskPortfolio` | `Identity[RiskResult].combine(child1, child2)` |

### Aggregation strategy

- We aggregate `RiskResult` values with an explicit, total `combine(a, b)` that enforces equal `nTrials` and sums losses per trial.
- Lawful Prelude instances are provided: `Associative[RiskResult]` and `Commutative[RiskResult]` both delegate to `RiskResult.combine`.
- An `Identity[RiskResult]` instance now exists in `RiskResultIdentityInstances`, but it is **scoped by `SimulationConfig`**; production code still uses non-empty folds with the total `combine` and must not assume a globally available identity.
- Tests and other explicitly opt-in contexts can summon that Identity by providing a `SimulationConfig` (which supplies `defaultNTrials`).

**Future-proofing:** Keep Identity context-bound to configuration so we can thread `nTrials` naturally and continue to encourage non-empty aggregation in production paths.

### Outer Join Merge Semantics

```scala
// LossDistribution.scala
def merge(distributions: LossDistribution*): Map[TrialId, Loss] = {
  val allTrialIds = distributions.foldLeft(Set.empty[TrialId])(_ ++ _.trialIds())
  
  allTrialIds.map { trial =>
    trial -> distributions.foldLeft(0L)((acc, d) => acc + d.outcomeOf(trial))
  }.toMap
}
```

**Example:**
```
Trial 1:  RiskA=1000, RiskB=500  → Aggregate=1500
Trial 2:  RiskA=0,    RiskB=200  → Aggregate=200  (RiskA missing = 0)
Trial 3:  RiskA=300,  RiskB=0    → Aggregate=300  (RiskB missing = 0)
```

### Tree Simulation with Bottom-Up Aggregation

```scala
// RiskResultResolverLive.scala (cache-aware simulation)
case portfolio: RiskPortfolio =>
  for {
    childResults <- ZIO.foreach(tree.index.children(portfolio.id)) { childId =>
      ensureCached(tree, childId)  // recursive, cache-aware
    }
    combined = childResults.combineAll  // using Identity[RiskResult]
    _ <- cache.put(portfolio.id, combined)
  } yield combined
```

---

## Data Model Summary

### Input: Risk Tree

```
RiskNode (sealed trait)
├── RiskLeaf: Has distribution parameters
│   - distributionType: "expert" | "lognormal"
│   - probability: Probability
│   - minLoss, maxLoss: Option[Long]
│   - (expert fields: percentiles, quantiles)
│
└── RiskPortfolio: Structural only
    - childIds: Array[NodeId]
```

### Output: Cached Results

Simulation results are cached per node in `RiskResultCache` (keyed by `NodeId`).
There is no separate result tree structure — the tree STRUCTURE comes from `RiskNode`,
and the simulation RESULTS live in the cache.

```
RiskResultCache: Map[NodeId, RiskResult]
├── NodeId("leaf-a")      → RiskResult (sampled from distribution)
├── NodeId("leaf-b")      → RiskResult (sampled from distribution)
└── NodeId("ops-risk")    → RiskResult (aggregated via Identity.combine)
```

### Serialization: LEC Response

```
LECCurveResponse
├── id: String             (NodeId.value)
├── name: String
├── curve: Vector[LECPoint]      ← Derived from RiskResult
├── quantiles: Map[String, Double]  ← p50, p90, p95, p99
└── childIds: Option[List[String]]
```

---

## Why This Works

### 1. Same Type, Same LEC

Since both leaves and aggregates are `RiskResult`:
- Both implement `LECCurve` trait
- Both have `probOfExceedance(threshold: Loss): BigDecimal`
- Both can generate `LECCurveResponse` via `LECGenerator`

### 2. Algebraic Properties Enable Caching

The `Identity` instance satisfies monoid laws:

| Property | Equation | Benefit |
|----------|----------|---------|
| Associativity | `(a ⊕ b) ⊕ c = a ⊕ (b ⊕ c)` | Order-independent aggregation |
| Left identity | `∅ ⊕ a = a` | Safe empty portfolios |
| Right identity | `a ⊕ ∅ = a` | Safe partial trees |

This enables:
- **Incremental recomputation**: If child C changes, recompute only ancestors
- **Parallel aggregation**: Combine children in any grouping
- **Subtree caching**: Cache `RiskResult` per node (see ADR-005)

### 3. Sparse Storage for Efficiency

```scala
outcomes: Map[TrialId, Loss]  // Only trials with non-zero loss
```

Low-probability risks have few entries (e.g., 2% probability → ~200 entries per 10,000 trials).

---

## Diagram

```
                    Input Tree                         Result Tree
                    
              ┌─────────────────┐              ┌─────────────────────┐
              │  RiskPortfolio  │              │       Branch        │
              │    "ops-risk"   │              │   result: Combined  │
              │ (no parameters) │    ────►     │   A ⊕ B ⊕ C         │
              └────────┬────────┘              └──────────┬──────────┘
                       │                                  │
         ┌─────────────┼─────────────┐      ┌─────────────┼─────────────┐
         │             │             │      │             │             │
    ┌────┴────┐   ┌────┴────┐   ┌────┴────┐ │        │         │
    │ Leaf A  │   │ Leaf B  │   │ Leaf C  │ ▼        ▼         ▼
    │ p=0.25  │   │ p=0.10  │   │ p=0.05  │ Leaf A   Leaf B    Leaf C
    │ lognorm │   │ expert  │   │ lognorm │ result:A result:B  result:C
    └─────────┘   └─────────┘   └─────────┘ (sampled)(sampled) (sampled)
                       
              Monte Carlo Sampling          Trial-wise Summation
              ─────────────────────────────────────────────────────►
```

---

## Code Smells

### ❌ Type Switching on Node Level

```scala
// BAD: Different types for different levels
def getLEC(node: AnyNode): LEC = node match {
  case leaf: LeafResult => leafToLEC(leaf)
  case agg: AggregateResult => aggregateToLEC(agg)  // Different logic!
}

// GOOD: Uniform type, uniform processing
def getLEC(result: RiskResult): LECCurveResponse =
  LECGenerator.generateLEC(result)  // Same for all levels
```

### ❌ Manual Trial Alignment

```scala
// BAD: Manual trial-by-trial summation
def aggregate(children: List[RiskResult]): Map[TrialId, Loss] = {
  val allTrials = children.flatMap(_.outcomes.keys).distinct
  allTrials.map { t =>
    t -> children.map(_.outcomes.getOrElse(t, 0L)).sum
  }.toMap
}

// GOOD: Use Identity.combine
def aggregate(children: List[RiskResult]): RiskResult =
  children.reduce(Identity[RiskResult].combine)
```

### ❌ Recompute Full Tree on Change

```scala
// BAD: Invalidate everything
def onNodeChanged(nodeId: NodeId): Task[Unit] =
  for
    tree <- getFullTree
    _ <- simulateEntireTree(tree)  // O(n) even for single leaf change
  yield ()

// GOOD: Invalidate path to root, recompute lazily (see ADR-005)
def onNodeChanged(nodeId: NodeId): Task[Unit] =
  cache.invalidateAncestors(nodeId)  // O(depth)
```

---

## Implementation Locations

| Component | Location | Purpose |
|-----------|----------|---------|
| `RiskResult` | `domain/data/LossDistribution.scala` | Leaf result type |
| `RiskResultGroup` | `domain/data/LossDistribution.scala` | Aggregate with children |
| `Identity[RiskResult]` | `domain/data/RiskResultIdentityInstances.scala` | ZIO Prelude instance (config-scoped) |
| `LossDistribution.combine` | `domain/data/LossDistribution.scala` | Outer join logic |
| `RiskResultResolverLive` | `services/cache/RiskResultResolverLive.scala` | Cache-aware simulation |
| `RiskResultCache` | `services/cache/RiskResultCache.scala` | Per-node result storage |
| `TreeCacheManager` | `services/cache/TreeCacheManager.scala` | Per-tree cache lifecycle |
| `Simulator` | `services/helper/Simulator.scala` | Trial-level Monte Carlo sampling |
| `LECGenerator` | `simulation/LECGenerator.scala` | `RiskResult` → `LECCurveResponse` |

### Architecture: Cache as Source of Truth

`RiskResult` per node is cached in `RiskResultCache`, keyed by `NodeId`. Tree structure for invalidation is provided by `TreeIndex`.

See **[ADR-015-proposal.md](./ADR-015-proposal.md)** for the pattern:
- **`RiskResultResolver.ensureCached(tree, nodeId)`**: Returns cached or freshly simulated result
- **Cache as source of truth**: No parallel result tree structure
- **`TreeCacheManager`**: Manages per-tree cache instances with O(depth) invalidation via `TreeIndex`

---

## Property Tests

The `Identity` laws are verified in `IdentityPropertySpec.scala`:

```scala
test("associativity: (a ⊕ b) ⊕ c = a ⊕ (b ⊕ c)") { ... }
test("left identity: ∅ ⊕ a = a") { ... }
test("right identity: a ⊕ ∅ = a") { ... }
```

---

## References

- ADR-005: Cached Subtree Aggregates (uses this pattern for O(depth) recomputation)
- ADR-014: RiskResult Caching Strategy (cache design)
- ADR-015-proposal: Cache Integration - RiskResultResolver pattern
- ZIO Prelude: https://zio.dev/zio-prelude/
- `IdentityPropertySpec.scala`: Property tests for monoid laws
