# ADR-001: Validation Strategy with Iron Types and Smart Constructors

**Status:** Accepted  
**Date:** 2026-01-09  
**Tags:** validation, iron, zio-prelude, ddd

---

## Context

- External input (HTTP, JSON) is **untrusted**
- Domain objects must be **correct by construction**
- Validation happens at **domain boundaries**, not scattered throughout
- Internal code trusts validated types

---

## Decision

### 1. Smart Constructor Pattern

Domain objects expose `create()` returning `Validation[ValidationError, DomainObject]`:

```scala
object RiskLeaf {
  def create(
    id: String,
    name: String,
    probability: Double,
    // ... raw inputs
  ): Validation[ValidationError, RiskLeaf] = {
    // Layer 1: Iron refinement (per-field)
    val idV = toValidation(ValidationUtil.refineId(id, "id"))
    val nameV = toValidation(ValidationUtil.refineName(name, "name"))
    val probV = toValidation(ValidationUtil.refineProbability(probability, "probability"))
    
    // Layer 2: Business rules (cross-field)
    // e.g., minLoss < maxLoss, expert mode requires percentiles + quantiles
    
    Validation.validateWith(idV, nameV, probV, ...) { ... => RiskLeaf(...) }
  }
}
```

### 2. JSON Parsing Calls Smart Constructor

Custom decoders ensure validation during parsing:

```scala
given decoder: JsonDecoder[RiskLeaf] = RiskLeafRaw.rawCodec.decoder.mapOrFail { raw =>
  RiskLeaf.create(raw.id, raw.name, raw.probability, ...)
    .toEither.left.map(errors => errors.mkString("; "))
}
```

No raw domain object can bypass validation.

### 3. Query Parameter Validation via Tapir Codecs

For HTTP query parameters, define Tapir codecs that validate at the HTTP layer:

```scala
// IronTapirCodecs.scala - validate during URL parsing
given Codec[String, PositiveInt, CodecFormat.TextPlain] =
  Codec.int.mapDecode[PositiveInt] { raw =>
    ValidationUtil.refinePositiveInt(raw, "value") match {
      case Right(pi) => DecodeResult.Value(pi)
      case Left(errs) => DecodeResult.Error(raw.toString, 
        new IllegalArgumentException(errs.map(_.message).mkString("; ")))
    }
  } { pi => pi: Int }

// Endpoint uses Iron type directly
.in(query[Option[PositiveInt]]("nTrials"))
.in(query[NonNegativeInt]("depth").default(DefaultDepth))
```

This follows "Parse, don't validate"—invalid input returns 400 Bad Request before reaching controllers.

### 4. Iron Types at Service Boundaries

Service signatures use Iron types. **No validation in service methods.**

```scala
trait RiskTreeService {
  def computeLEC(
    id: NonNegativeLong,             // Iron type (domain identifier)
    nTrials: Option[PositiveInt],    // Iron type
    parallelism: PositiveInt,         // Iron type
    depth: NonNegativeInt            // Iron type
  ): Task[RiskTreeWithLEC]
}
```

Controllers are "dumb"—they wire endpoints to services, not validate.  
Validation happens at the earliest boundary:
- **JSON body**: Decoders call smart constructors
- **Query params**: Tapir codecs refine to Iron types
- **Path params (IDs)**: Tapir codecs refine to Iron types

Service methods and internal methods use validated types—no re-validation.

### 5. Path Parameters for Domain Identifiers

**For internally-generated domain identifiers** (e.g., auto-incrementing IDs, UUIDs assigned by repository):

```scala
// IronTapirCodecs.scala - validate at HTTP boundary
given Codec[String, NonNegativeLong, CodecFormat.TextPlain] =
  Codec.long.mapDecode[NonNegativeLong](raw =>
    ValidationUtil.refineNonNegativeLong(raw, "id").fold(
      errs => DecodeResult.Error(...),
      DecodeResult.Value(_)
    )
  )(identity)

// Endpoint - use domain type
.in("risk-trees" / path[NonNegativeLong]("id"))

// Controller - no parsing, just wire
val getById = getByIdEndpoint.serverLogicSuccess { id =>
  riskTreeService.getById(id)  // id already validated NonNegativeLong
}

// Service/Repository - use same domain type throughout
trait RiskTreeService {
  def getById(id: NonNegativeLong): Task[Option[RiskTree]]
}
trait RiskTreeRepository {
  def getById(id: NonNegativeLong): Task[Option[RiskTree]]
}

// Repository implementation - domain type in storage
private val db = TrieMap[NonNegativeLong, RiskTree]()
```

**Rationale:**
1. **Type Alignment**: Domain model (`RiskTree.id: NonNegativeLong`) matches all layers
2. **Single Source of Truth**: Change ID type once (type alias), codec updates automatically
3. **Future-Proof**: UUID migration = change type alias + codec, not all signatures
4. **No Controller Parsing**: Adheres to "parse at boundary" principle strictly
5. **Repository Clarity**: Map key type documents what IDs are valid

**Alternative (NOT recommended):**
Using `path[String]("id")` and parsing to `Long` in controller violates "parse at boundary" and creates type mismatch between HTTP layer and domain.

### 6. Error Accumulation

Use `Validation[E, A]` (ZIO Prelude), not `Either` (fails on first error).

---

## Code Smells

### ❌ Parsing in Controller (Path Parameters)

```scala
// BAD: Controller parses String → Long, bypasses HTTP validation
.in("risk-trees" / path[String]("id"))

val getById = getByIdEndpoint.serverLogicSuccess { idStr =>
  ZIO.attempt(idStr.toLong)  // Parsing in controller!
    .flatMap(riskTreeService.getById)
}

// GOOD: Tapir codec parses and validates at HTTP boundary
.in("risk-trees" / path[NonNegativeLong]("id"))

val getById = getByIdEndpoint.serverLogicSuccess { id =>
  riskTreeService.getById(id)  // Already validated NonNegativeLong
}
```

**Why this matters:**
- Non-numeric input (e.g., `/risk-trees/abc`) should return 400 Bad Request from Tapir, not 500 from controller
- Domain identifier type (`NonNegativeLong`) should flow through all layers for consistency
- UUID migration becomes trivial: change type alias + codec, not all controllers/services

### ❌ Validation in Controller

```scala
// BAD: Controller validates query parameters
val computeLEC = computeLECEndpoint.serverLogic { (idStr, nTrials, depth) =>
  for {
    validTrials <- ZIO.fromEither(ValidationUtil.refinePositiveInt(nTrials, "nTrials"))
    validDepth <- ZIO.fromEither(ValidationUtil.refineNonNegativeInt(depth, "depth"))
    result <- service.computeLEC(id, validTrials, validDepth)
  } yield result
}

// GOOD: Tapir codec validates, controller just wires
.in(query[PositiveInt]("nTrials"))  // Codec validates
.in(query[NonNegativeInt]("depth")) // Codec validates

val computeLEC = computeLECEndpoint.serverLogic { (idStr, nTrials, depth) =>
  // nTrials and depth already validated Iron types
  service.computeLEC(id, nTrials, depth)
}
```

### ❌ Validation in Service Layer

```scala
// BAD: Service validates raw types
def computeLEC(nTrials: Int, depth: Int) = {
  val validated = for {
    validTrials <- ValidationUtil.refinePositiveInt(nTrials, "nTrials")
    validDepth <- ValidationUtil.refineNonNegativeInt(depth, "depth")
  } yield (validTrials, validDepth)
  // ...
}

// GOOD: Service trusts Iron types
def computeLEC(nTrials: PositiveInt, depth: NonNegativeInt) = {
  // No validation - types guarantee correctness
}
```

### ❌ Option-based Smart Constructors

```scala
// BAD: No error information, no accumulation
def create(name: String): Option[SafeName] =
  if (name.nonEmpty && name.length <= 50) Some(SafeName(name)) else None

// GOOD: Rich errors, accumulation
def create(name: String): Validation[ValidationError, SafeName] =
  toValidation(ValidationUtil.refineName(name, "name"))
```

### ❌ Fail-Fast with Either

```scala
// BAD: User sees only first error
for {
  id <- ValidationUtil.refineId(id, "id").left.map(_.head)
  name <- ValidationUtil.refineName(name, "name").left.map(_.head)
} yield ...

// GOOD: All errors reported
Validation.validateWith(
  toValidation(ValidationUtil.refineId(id, "id")),
  toValidation(ValidationUtil.refineName(name, "name"))
) { (id, name) => ... }
```

### ❌ Bypassing with `.refineUnsafe`

```scala
// BAD: Runtime exception if invalid
val nTrials = input.refineUnsafe[Greater[0]]

// GOOD: Proper validation at boundary
ValidationUtil.refinePositiveInt(input, "nTrials")
```

---

## Implementation

| Location | Pattern |
|----------|---------|
| `RiskLeaf.create()` | Smart constructor with Validation |
| `RiskPortfolio.create()` | Smart constructor with Validation |
| `JsonDecoder[RiskLeaf]` | Calls `create()` during parsing |
| `IronTapirCodecs` | Tapir codecs for query params and path params |
| `RiskTreeEndpoints` | Uses Iron types (including `NonNegativeLong` for IDs) |
| `RiskTreeController` | Wires only—no validation or parsing logic |
| `RiskTreeService` | Iron types in signatures (including `NonNegativeLong` for IDs) |
| `RiskTreeRepository` | Iron types in signatures and storage keys |
| `ValidationUtil` | Iron refinement helpers |

---

## References

- [Iron Library](https://github.com/Iltotore/iron)
- [ZIO Prelude Validation](https://zio.dev/zio-prelude/validation/)
- [Parse, Don't Validate](https://lexi-lambda.github.io/blog/2019/11/05/parse-don-t-validate/)
