# ADR-001: Validation Strategy with Iron Types and Smart Constructors

**Status:** Accepted  
**Date:** 2026-01-09  
**Tags:** validation, iron, zio-prelude, ddd

---

## Context

- External input (HTTP, JSON) is **untrusted**
- Domain objects must be **correct by construction**
- Validation happens at **domain boundaries**, not scattered throughout
- Internal code trusts validated types

---

## Decision

### 1. Smart Constructor Pattern

Domain objects expose `create()` returning `Validation[ValidationError, DomainObject]`:

```scala
object RiskLeaf {
  def create(
    id: String,
    name: String,
    probability: Double,
    // ... raw inputs
  ): Validation[ValidationError, RiskLeaf] = {
    // Layer 1: Iron refinement (per-field)
    val idV = toValidation(ValidationUtil.refineId(id, "id"))
    val nameV = toValidation(ValidationUtil.refineName(name, "name"))
    val probV = toValidation(ValidationUtil.refineProbability(probability, "probability"))
    
    // Layer 2: Business rules (cross-field)
    // e.g., minLoss < maxLoss, expert mode requires percentiles + quantiles
    
    Validation.validateWith(idV, nameV, probV, ...) { ... => RiskLeaf(...) }
  }
}
```

### 2. JSON Parsing Calls Smart Constructor

Custom decoders ensure validation during parsing:

```scala
given decoder: JsonDecoder[RiskLeaf] = RiskLeafRaw.rawCodec.decoder.mapOrFail { raw =>
  RiskLeaf.create(raw.id, raw.name, raw.probability, ...)
    .toEither.left.map(errors => errors.mkString("; "))
}
```

No raw domain object can bypass validation.

### 3. Query Parameter Validation via Tapir Codecs

For HTTP query parameters, define Tapir codecs that validate at the HTTP layer:

```scala
// IronTapirCodecs.scala - validate during URL parsing
given Codec[String, PositiveInt, CodecFormat.TextPlain] =
  Codec.int.mapDecode[PositiveInt] { raw =>
    ValidationUtil.refinePositiveInt(raw, "value") match {
      case Right(pi) => DecodeResult.Value(pi)
      case Left(errs) => DecodeResult.Error(raw.toString, 
        new IllegalArgumentException(errs.map(_.message).mkString("; ")))
    }
  } { pi => pi: Int }

// Endpoint uses Iron type directly
.in(query[Option[PositiveInt]]("nTrials"))
.in(query[NonNegativeInt]("depth").default(DefaultDepth))
```

This follows "Parse, don't validate"—invalid input returns 400 Bad Request before reaching controllers.

### 4. Iron Types at Service Boundaries

Service signatures use Iron types. **No validation in service methods.**

```scala
trait RiskTreeService {
  def computeLEC(
    id: NonNegativeLong,             // Iron type (domain identifier)
    nTrials: Option[PositiveInt],    // Iron type
    parallelism: PositiveInt,         // Iron type
    depth: NonNegativeInt            // Iron type
  ): Task[RiskTreeWithLEC]
}
```

Controllers are "dumb"—they wire endpoints to services, not validate.  
Validation happens at the earliest boundary:
- **JSON body**: Decoders call smart constructors
- **Query params**: Tapir codecs refine to Iron types
- **Path params (IDs)**: Tapir codecs refine to Iron types

### 5. URL Refinements: Internal vs Public

- Internal/service URLs (docker, k8s, localhost, IPv4/IPv6 with optional ports/paths) use the relaxed `SafeUrl` constraint (http/https only, regex-based to allow non-public hostnames).
- If we later accept user-supplied/public web URLs, introduce a distinct `PublicUrl` type that can leverage Iron's `ValidURL` or a stricter regex. Only add this stricter type when a real public-input use case exists to avoid over-constraining internal endpoints.

Service methods and internal methods use validated types—no re-validation.

### 7. Internal Domain Structures

All internal data structures that reference domain entities (caches, indexes, 
event queues, etc.) MUST use the same Iron types as the domain model.

```scala
// ❌ BAD: nodeId as raw String in cache
final case class LECCache(
  cache: Map[String, LECCurveData]  // Raw String for domain ID
)

// ✅ GOOD: Use SafeId.SafeId consistently
final case class LECCache(
  cache: Map[SafeId.SafeId, LECCurveData]  // Matches RiskNode.safeId
)

// ❌ BAD: TreeIndex with String keys
final case class TreeIndex(
  nodes: Map[String, RiskNode],
  parents: Map[String, String]
)

// ✅ GOOD: TreeIndex with NodeId (type alias for SafeId.SafeId)
type NodeId = SafeId.SafeId
final case class TreeIndex(
  nodes: Map[NodeId, RiskNode],
  parents: Map[NodeId, NodeId]
)
```

**Rationale:**
- Domain IDs should flow through all internal structures, not just boundaries
- Prevents accidental String/ID mixing in caches and indexes
- Enables type-safe lookups and comparisons

### 5. Path Parameters for Domain Identifiers

**For internally-generated domain identifiers** (e.g., auto-incrementing IDs, UUIDs assigned by repository):

```scala
// IronTapirCodecs.scala - validate at HTTP boundary
given Codec[String, NonNegativeLong, CodecFormat.TextPlain] =
  Codec.long.mapDecode[NonNegativeLong](raw =>
    ValidationUtil.refineNonNegativeLong(raw, "id").fold(
      errs => DecodeResult.Error(...),
      DecodeResult.Value(_)
    )
  )(identity)

// Endpoint - use domain type
.in("risk-trees" / path[NonNegativeLong]("id"))

// Controller - no parsing, just wire
val getById = getByIdEndpoint.serverLogicSuccess { id =>
  riskTreeService.getById(id)  // id already validated NonNegativeLong
}

// Service/Repository - use same domain type throughout
trait RiskTreeService {
  def getById(id: NonNegativeLong): Task[Option[RiskTree]]
}
trait RiskTreeRepository {
  def getById(id: NonNegativeLong): Task[Option[RiskTree]]
}

// Repository implementation - domain type in storage
private val db = TrieMap[NonNegativeLong, RiskTree]()
```

**Rationale:**
1. **Type Alignment**: Domain model (`RiskTree.id: NonNegativeLong`) matches all layers
2. **Single Source of Truth**: Change ID type once (type alias), codec updates automatically
3. **Future-Proof**: UUID migration = change type alias + codec, not all signatures
4. **No Controller Parsing**: Adheres to "parse at boundary" principle strictly
5. **Repository Clarity**: Map key type documents what IDs are valid

**Alternative (NOT recommended):**
Using `path[String]("id")` and parsing to `Long` in controller violates "parse at boundary" and creates type mismatch between HTTP layer and domain.

### 6. JSON Bodies with Iron Types

**When a JSON body contains Iron types directly** (not wrapped in a DTO with smart constructor):

```scala
// Endpoint accepts List[SafeId.SafeId] directly
val getLECCurvesMultiEndpoint =
  baseEndpoint
    .in("risk-trees" / path[NonNegativeLong]("treeId") / "nodes" / "lec-multi")
    .post
    .in(jsonBody[List[SafeId.SafeId]])  // Iron type in JSON body
    .out(jsonBody[Map[String, Vector[LECPoint]]])
```

Tapir's `jsonBody[T]` requires **two** things for Iron types:

1. **JsonCodec[IronType]** - For ZIO JSON serialization
   ```scala
   // In domain object companion (e.g., RiskLeaf)
   given JsonEncoder[SafeId.SafeId] = JsonEncoder[String].contramap(_.value.toString)
   given JsonDecoder[SafeId.SafeId] = JsonDecoder[String].mapOrFail(s => 
     SafeId.fromString(s).left.map(_.mkString(", "))
   )
   ```

2. **Schema[IronType]** - For OpenAPI documentation
   ```scala
   // In IronTapirCodecs
   given Schema[SafeId.SafeId] = Schema.string
   ```

**Key distinction from path/query params:**
- Path/query params: Tapir derives Schema from Codec automatically
- JSON body: Schema must be provided explicitly for Iron types

**Controller remains "dumb":**
```scala
// Controller receives validated Iron types - no parsing
val getLECCurvesMulti = getLECCurvesMultiEndpoint.serverLogicSuccess {
  case (treeId, nodeIds) =>  // nodeIds: List[SafeId.SafeId]
    riskTreeService.getLECCurvesMulti(nodeIds.toSet)
}
```

### 7. Error Accumulation

Use `Validation[E, A]` (ZIO Prelude), not `Either` (fails on first error).

---

## Code Smells

### ❌ Parsing in Controller (Path Parameters)

```scala
// BAD: Controller parses String → Long, bypasses HTTP validation
.in("risk-trees" / path[String]("id"))

val getById = getByIdEndpoint.serverLogicSuccess { idStr =>
  ZIO.attempt(idStr.toLong)  // Parsing in controller!
    .flatMap(riskTreeService.getById)
}

// GOOD: Tapir codec parses and validates at HTTP boundary
.in("risk-trees" / path[NonNegativeLong]("id"))

val getById = getByIdEndpoint.serverLogicSuccess { id =>
  riskTreeService.getById(id)  // Already validated NonNegativeLong
}
```

**Why this matters:**
- Non-numeric input (e.g., `/risk-trees/abc`) should return 400 Bad Request from Tapir, not 500 from controller
- Domain identifier type (`NonNegativeLong`) should flow through all layers for consistency
- UUID migration becomes trivial: change type alias + codec, not all controllers/services

### ❌ Validation in Controller

```scala
// BAD: Controller validates query parameters
val computeLEC = computeLECEndpoint.serverLogic { (idStr, nTrials, depth) =>
  for {
    validTrials <- ZIO.fromEither(ValidationUtil.refinePositiveInt(nTrials, "nTrials"))
    validDepth <- ZIO.fromEither(ValidationUtil.refineNonNegativeInt(depth, "depth"))
    result <- service.computeLEC(id, validTrials, validDepth)
  } yield result
}

// GOOD: Tapir codec validates, controller just wires
.in(query[PositiveInt]("nTrials"))  // Codec validates
.in(query[NonNegativeInt]("depth")) // Codec validates

val computeLEC = computeLECEndpoint.serverLogic { (idStr, nTrials, depth) =>
  // nTrials and depth already validated Iron types
  service.computeLEC(id, nTrials, depth)
}
```

### ❌ Validation in Service Layer

```scala
// BAD: Service validates raw types
def computeLEC(nTrials: Int, depth: Int) = {
  val validated = for {
    validTrials <- ValidationUtil.refinePositiveInt(nTrials, "nTrials")
    validDepth <- ValidationUtil.refineNonNegativeInt(depth, "depth")
  } yield (validTrials, validDepth)
  // ...
}

// GOOD: Service trusts Iron types
def computeLEC(nTrials: PositiveInt, depth: NonNegativeInt) = {
  // No validation - types guarantee correctness
}
```

### ❌ Option-based Smart Constructors

```scala
// BAD: No error information, no accumulation
def create(name: String): Option[SafeName] =
  if (name.nonEmpty && name.length <= 50) Some(SafeName(name)) else None

// GOOD: Rich errors, accumulation
def create(name: String): Validation[ValidationError, SafeName] =
  toValidation(ValidationUtil.refineName(name, "name"))
```

### ❌ Fail-Fast with Either

```scala
// BAD: User sees only first error
for {
  id <- ValidationUtil.refineId(id, "id").left.map(_.head)
  name <- ValidationUtil.refineName(name, "name").left.map(_.head)
} yield ...

// GOOD: All errors reported
Validation.validateWith(
  toValidation(ValidationUtil.refineId(id, "id")),
  toValidation(ValidationUtil.refineName(name, "name"))
) { (id, name) => ... }
```

### ❌ Bypassing with `.refineUnsafe`

```scala
// BAD: Runtime exception if invalid
val nTrials = input.refineUnsafe[Greater[0]]

// GOOD: Proper validation at boundary
ValidationUtil.refinePositiveInt(input, "nTrials")
```

---

## Implementation

| Location | Pattern |
|----------|---------|
| `RiskLeaf.create()` | Smart constructor with Validation |
| `RiskPortfolio.create()` | Smart constructor with Validation |
| `JsonDecoder[RiskLeaf]` | Calls `create()` during parsing |
| `IronTapirCodecs` | Tapir codecs for query params and path params |
| `RiskTreeEndpoints` | Uses Iron types (including `NonNegativeLong` for IDs) |
| `RiskTreeController` | Wires only—no validation or parsing logic |
| `RiskTreeService` | Iron types in signatures (including `NonNegativeLong` for IDs) |
| `RiskTreeRepository` | Iron types in signatures and storage keys |
| `ValidationUtil` | Iron refinement helpers |

---

## Executable Validation Checklist

Before completing any PR or implementation phase, run these commands to verify compliance:

```bash
# 1. Check for raw String domain IDs in Map/Set types (should return 0 matches outside tests)
grep -rn "Map\[String" modules/server/src/main/scala --include="*.scala" | grep -v "Config\|Json\|Env"

# 2. Check for String keys in cache/index structures
grep -rn "cache.*String\|index.*String" modules/server/src/main/scala --include="*.scala"

# 3. Verify all service methods use Iron types (look for raw primitives)
grep -rn "def.*nodeId: String\|def.*id: String\|def.*id: Long" modules/server/src/main/scala/com/risquanter/register/services --include="*.scala"

# 4. Check for .refineUnsafe usage (should be minimal, only in test helpers)
grep -rn "refineUnsafe" modules/server/src --include="*.scala"
```

Each command should return **zero results** in production code (main/scala). Any matches require review.

---

## Red Flags (Stop and Verify)

If you observe any of these patterns while implementing, **STOP and verify against this ADR**:

| Pattern | Concern | Correct Approach |
|---------|---------|------------------|
| `Map[String, DomainObject]` | Raw String as domain ID key | Use `Map[NodeId, DomainObject]` with NodeId = SafeId.SafeId |
| `def method(id: String)` in service | Raw String parameter in service signature | Use refined type: `def method(id: SafeId.SafeId)` |
| `node.id` for lookups | Extracting String from domain object | Use `node.safeId` to preserve type |
| `cache.get(id.toString)` | Converting Iron type to String for lookup | Use Iron type directly as key |
| `.refineUnsafe` in production code | Bypassing validation | Use `fromString(...).getOrElse(...)` or smart constructors |
| `String :| Constraint` in new code | Defining inline refined type | Use existing type aliases (NodeId, SafeId.SafeId) |

**When in doubt:** If a value represents a domain entity identifier, it should use the same Iron type as the domain model.

---

## References

- [Iron Library](https://github.com/Iltotore/iron)
- [ZIO Prelude Validation](https://zio.dev/zio-prelude/validation/)
- [Parse, Don't Validate](https://lexi-lambda.github.io/blog/2019/11/05/parse-don-t-validate/)
