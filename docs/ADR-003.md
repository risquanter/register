# ADR-003: Provenance and Reproducibility

**Status:** Accepted  
**Date:** 2026-01-04  
**Updated:** 2026-01-20  
**Tags:** provenance, reproducibility, hdr, monte-carlo, determinism

---

## Context

- Monte Carlo simulations must be **reproducible** for auditing and verification
- Random number generation needs **deterministic** behavior across runs
- Provenance data should enable **exact reproduction** of simulation results
- Zero overhead when provenance is not needed (opt-in feature)
- Distribution parameters must be **serializable** for later reconstruction

---

## Decision

### 1. HDR-Based 4-Layer Seed Hierarchy

Deterministic random number generation using HDR (Hash-based Deterministic Random) with 4-layer seed hierarchy:

```scala
// HDR seed hierarchy
HDR.generate(counter, entityId, varId, seed3, seed4)
             ↓        ↓        ↓      ↓      ↓
             trial    entity   variable global global

// Layer 1: Trial number (0..nTrials)
// Layer 2: Entity isolation (hash of riskId)
entityId = leaf.id.hashCode.toLong

// Layer 3: Variable isolation (occurrence vs loss)
occurrenceVarId = entityId.hashCode + 1000L
lossVarId = entityId.hashCode + 2000L

// Layer 4: Global seeds (from SimulationConfig)
seed3 = config.defaultSeed3  // Configurable via REGISTER_SEED3 env var
seed4 = config.defaultSeed4  // Configurable via REGISTER_SEED4 env var
```

**Why 4 layers:**
- **Trial isolation**: Same entity produces different values per trial
- **Entity isolation**: Different risks have independent random streams
- **Variable isolation**: Occurrence and loss sampling are uncorrelated
- **Global control**: User can change entire simulation outcome with one parameter

### 2. Service-Wide Simulation Parameters

All simulation parameters come from `SimulationConfig`, not per-tree or per-request:

```scala
// SimulationConfig (application.conf / environment variables)
final case class SimulationConfig(
  defaultNTrials: Int,        // REGISTER_DEFAULT_NTRIALS
  defaultParallelism: Int,    // REGISTER_PARALLELISM
  defaultSeed3: Long,         // REGISTER_SEED3
  defaultSeed4: Long,         // REGISTER_SEED4
  // ... other config
)

// RiskResultResolverLive reads from config at construction
private val nTrials = config.defaultNTrials
private val parallelism = config.defaultParallelism
private val seed3 = config.defaultSeed3
private val seed4 = config.defaultSeed4
```

**Why service-wide:**
- Consistent reproducibility across all simulations
- Configuration via environment variables for different environments
- Cache keys are simpler (no per-request variation)
- `RiskResult.nTrials` ensures aggregation only combines compatible results

### 3. Optional Provenance Capture

Provenance is opt-in via `includeProvenance` flag:

```scala
// RiskResult stores provenance list (aggregated from children)
case class RiskResult(
  name: SafeId.SafeId,
  outcomes: Map[TrialId, Loss],
  nTrials: Int,
  provenances: List[NodeProvenance] = Nil  // Empty by default
)

// NodeProvenance captures per-node reproducibility info
case class NodeProvenance(
  riskId: SafeId.SafeId,
  entityId: Long,
  occurrenceVarId: Long,
  lossVarId: Long,
  globalSeed3: Long,
  globalSeed4: Long,
  distributionType: String,
  distributionParams: DistributionParams,
  timestamp: Instant,
  simulationUtilVersion: String
)
```

**Aggregation behavior:**
- `Identity[RiskResult].combine` accumulates provenances: `a.provenances ++ b.provenances`
- Portfolio nodes aggregate child provenances, no additional provenance added
- Leaf nodes add their single provenance to the list

**Why in RiskResult (deviation from original design):**
- Original ADR suggested separate `TreeProvenance` companion
- Current implementation embeds `List[NodeProvenance]` in `RiskResult` for caching convenience
- This is a minor pragmatic deviation; provenance is still opt-in (defaults to Nil)

> **Note:** `TreeProvenance` exists in code but is unused (dead code). The `RiskTreeWithLEC.provenance` field is never populated. Future cleanup should remove `TreeProvenance`.

### 4. Distribution Parameters Storage

Store all parameters needed to reconstruct exact distribution:

```scala
sealed trait DistributionParams

case class MetalogParams(
  percentiles: Array[Double],   // [0.1, 0.5, 0.9]
  quantiles: Array[Double],     // [1000, 5000, 20000]
  terms: Int,                   // 3 or 9 terms
  lowerBound: Option[Double],   // Semi-bounded
  upperBound: Option[Double]
) extends DistributionParams

case class LognormalParams(
  minLoss: Long,                // P05 (90% CI lower)
  maxLoss: Long,                // P95 (90% CI upper)
  confidenceInterval: Double = 0.90
) extends DistributionParams
```

**Why capture both types:**
- Expert opinion (Metalog) needs percentiles + quantiles
- Lognormal needs confidence interval bounds
- Enables exact distribution reconstruction

### 5. Per-Node Provenance

Each risk node captures its own provenance independently:

```scala
case class NodeProvenance(
  // HDR Configuration
  riskId: String,
  entityId: Long,
  occurrenceVarId: Long,
  lossVarId: Long,
  globalSeed3: Long,
  globalSeed4: Long,
  
  // Distribution
  distributionType: String,
  distributionParams: DistributionParams,
  
  // Metadata
  timestamp: Instant,
  simulationUtilVersion: String
)
```

**Why per-node:**
- Each risk has independent random streams
- Portfolio aggregation doesn't need provenance (sum of children)
- Enables partial tree reproduction

---

## Code Smells

### ❌ Global Seed State

```scala
// BAD: Mutable global seed
object RandomState {
  var globalSeed: Long = 0L
  def nextRandom(): Double = { /* mutate state */ }
}

// GOOD: Pure HDR function
def sample(trial: Int, entityId: Long, varId: Long, seed3: Long, seed4: Long): Double =
  HDR.generate(trial, entityId, varId, seed3, seed4)
```

### ❌ Missing Variable Isolation

```scala
// BAD: Occurrence and loss share same varId
val occurred = HDR.generate(trial, entityId, varId = entityId, seed3, seed4) < prob
val loss = HDR.generate(trial, entityId, varId = entityId, seed3, seed4) * scale
// Result: Biased correlation between occurrence and loss

// GOOD: Independent streams
val occurrenceVarId = entityId.hashCode + 1000L
val lossVarId = entityId.hashCode + 2000L
val occurred = HDR.generate(trial, entityId, occurrenceVarId, seed3, seed4) < prob
val loss = HDR.generate(trial, entityId, lossVarId, seed3, seed4) * scale
```

### ❌ Embedding Provenance in Domain Objects

```scala
// BAD: Domain object couples to provenance
case class RiskResult(
  losses: Map[TrialId, Loss],
  provenance: NodeProvenance  // Always present, even when not needed
)

// GOOD: Provenance as separate companion
case class RiskResult(losses: Map[TrialId, Loss])

// Service returns tuple when provenance requested
def simulate(..., includeProvenance: Boolean): Task[(RiskResult, Option[NodeProvenance])]
```

### ❌ Incomplete Distribution Parameters

```scala
// BAD: Can't reconstruct distribution
case class MetalogParams(
  terms: Int  // Missing percentiles/quantiles
)

// GOOD: All parameters for reconstruction
case class MetalogParams(
  percentiles: Array[Double],
  quantiles: Array[Double],
  terms: Int,
  lowerBound: Option[Double],
  upperBound: Option[Double]
)
```

---

## Reproduction Workflow

1. **Extract provenance** from `RiskResult.provenances`
2. **For each `NodeProvenance`**, reconstruct the leaf's distribution
3. **Create `RiskSampler`** with exact HDR parameters from provenance
4. **Run simulation** with same `nTrials` (from `RiskResult.nTrials`)
5. **Verify**: Results match original within floating-point precision

---

## Implementation

| Component | Status |
|-----------|--------|
| HDR 4-layer hierarchy | ✅ Implemented |
| `NodeProvenance` | ✅ Implemented |
| `TreeProvenance` | ⚠️ Dead code (unused) |
| `DistributionParams` sealed trait | ✅ Implemented |
| Optional provenance capture | ✅ Implemented (`includeProvenance` flag) |
| JSON serialization | ✅ Implemented |
| Global seeds from config | ✅ Implemented (`SimulationConfig.defaultSeed3/4`) |
| nTrials from config | ✅ Implemented (`SimulationConfig.defaultNTrials`) |
| Provenance in RiskResult | ✅ Implemented (`provenances: List[NodeProvenance]`) |

### Architectural Notes

**Deviation from original design:**
- Original ADR specified `TreeProvenance` as a separate response companion
- Current implementation uses `List[NodeProvenance]` embedded in `RiskResult`
- This simplifies caching (provenance travels with cached result)
- Aggregation via `Identity[RiskResult].combine` accumulates provenances correctly

**Dead code to clean up:**
- `TreeProvenance` case class in `Provenance.scala`
- `provenance: Option[TreeProvenance]` field in `RiskTreeWithLEC`
- `RiskTreeDefinitionRequest.nTrials` field (deprecated, ignored)

---

## References

- [HDR Paper](https://arxiv.org/abs/2004.06278) - Hash-based Deterministic Random
- simulation-util 0.8.0 - HDR implementation
- ADR-001: Validation Strategy (boundary patterns)
- ADR-015: RiskResultResolver (cache-aside pattern)
