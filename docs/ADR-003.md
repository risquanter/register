# ADR-003: Provenance and Reproducibility

**Status:** Accepted  
**Date:** 2026-01-04  
**Updated:** 2026-02-09  
**Tags:** provenance, reproducibility, hdr, monte-carlo, determinism

---

## Context

- Monte Carlo simulations must be **reproducible** for auditing and verification
- Random number generation needs **deterministic** behavior across runs
- Provenance data should enable **exact reproduction** of simulation results
- Zero overhead when provenance is not needed (opt-in feature)
- Distribution parameters must be **serializable** for later reconstruction

---

## Decision

### 1. HDR-Based 4-Layer Seed Hierarchy

Deterministic random number generation using HDR (Hash-based Deterministic Random) with 4-layer seed hierarchy:

```scala
// HDR seed hierarchy
HDR.generate(counter, entityId, varId, seed3, seed4)
             ↓        ↓        ↓      ↓      ↓
             trial    entity   variable global global

// Layer 1: Trial number (0..nTrials)
// Layer 2: Entity isolation (hash of riskId)
entityId = leaf.id.hashCode.toLong

// Layer 3: Variable isolation (occurrence vs loss)
occurrenceVarId = entityId.hashCode + 1000L
lossVarId = entityId.hashCode + 2000L

// Layer 4: Global seeds (from SimulationConfig)
seed3 = config.defaultSeed3  // Configurable via REGISTER_SEED3 env var
seed4 = config.defaultSeed4  // Configurable via REGISTER_SEED4 env var
```

**Why 4 layers:**
- **Trial isolation**: Same entity produces different values per trial
- **Entity isolation**: Different risks have independent random streams
- **Variable isolation**: Occurrence and loss sampling are uncorrelated
- **Global control**: User can change entire simulation outcome with one parameter

### 2. Service-Wide Simulation Parameters

All simulation parameters come from `SimulationConfig`, not per-tree or per-request:

```scala
// SimulationConfig (application.conf / environment variables)
final case class SimulationConfig(
  defaultNTrials: Int,        // REGISTER_DEFAULT_NTRIALS
  defaultParallelism: Int,    // REGISTER_PARALLELISM
  defaultSeed3: Long,         // REGISTER_SEED3
  defaultSeed4: Long,         // REGISTER_SEED4
  // ... other config
)

// RiskResultResolverLive reads from config at construction
private val nTrials = config.defaultNTrials
private val parallelism = config.defaultParallelism
private val seed3 = config.defaultSeed3
private val seed4 = config.defaultSeed4
```

**Why service-wide:**
- Consistent reproducibility across all simulations
- Configuration via environment variables for different environments
- Cache keys are simpler (no per-request variation)
- `RiskResult.nTrials` ensures aggregation only combines compatible results

### 3. Optional Provenance Capture

Provenance is opt-in via `includeProvenance` flag:

```scala
// RiskResult stores provenance list (aggregated from children)
case class RiskResult(
  nodeId: NodeId,
  outcomes: Map[TrialId, Loss],
  provenances: List[NodeProvenance] = Nil  // Empty by default
) extends LossDistribution with LECCurve

// NodeProvenance captures per-node reproducibility info
case class NodeProvenance(
  riskId: NodeId,
  entityId: Long,
  occurrenceVarId: Long,
  lossVarId: Long,
  globalSeed3: Long,
  globalSeed4: Long,
  distributionType: String,
  distributionParams: DistributionParams,
  timestamp: Instant,
  simulationUtilVersion: String
)
```

**Aggregation behavior:**
- `Identity[RiskResult].combine` accumulates provenances: `a.provenances ++ b.provenances`
- Portfolio nodes aggregate child provenances, no additional provenance added
- Leaf nodes add their single provenance to the list

**Why embedded in `RiskResult`:**
- Provenance travels with the cached result — no separate lookup needed
- `Identity[RiskResult].combine` accumulates provenances automatically during aggregation
- Opt-in via `Nil` default — zero overhead when provenance is not requested
- Eliminates the need for a separate tree-level provenance structure

### 4. Distribution Parameters Storage

Store all parameters needed to reconstruct exact distribution:

```scala
sealed trait DistributionParams

case class MetalogParams(
  percentiles: Array[Double],   // [0.1, 0.5, 0.9]
  quantiles: Array[Double],     // [1000, 5000, 20000]
  terms: Int,                   // 3 or 9 terms
  lowerBound: Option[Double],   // Semi-bounded
  upperBound: Option[Double]
) extends DistributionParams

case class LognormalParams(
  minLoss: Long,                // P05 (90% CI lower)
  maxLoss: Long,                // P95 (90% CI upper)
  confidenceInterval: Double = 0.90
) extends DistributionParams
```

**Why capture both types:**
- Expert opinion (Metalog) needs percentiles + quantiles
- Lognormal needs confidence interval bounds
- Enables exact distribution reconstruction

### 5. Per-Node Provenance

Each risk node captures its own provenance independently:

```scala
case class NodeProvenance(
  // HDR Configuration
  riskId: NodeId,
  entityId: Long,
  occurrenceVarId: Long,
  lossVarId: Long,
  globalSeed3: Long,
  globalSeed4: Long,
  
  // Distribution
  distributionType: String,
  distributionParams: DistributionParams,
  
  // Metadata
  timestamp: Instant,
  simulationUtilVersion: String
)
```

**Why per-node:**
- Each risk has independent random streams
- Portfolio aggregation doesn't need provenance (sum of children)
- Enables partial tree reproduction

---

## Code Smells

### ❌ Global Seed State

```scala
// BAD: Mutable global seed
object RandomState {
  var globalSeed: Long = 0L
  def nextRandom(): Double = { /* mutate state */ }
}

// GOOD: Pure HDR function
def sample(trial: Int, entityId: Long, varId: Long, seed3: Long, seed4: Long): Double =
  HDR.generate(trial, entityId, varId, seed3, seed4)
```

### ❌ Missing Variable Isolation

```scala
// BAD: Occurrence and loss share same varId
val occurred = HDR.generate(trial, entityId, varId = entityId, seed3, seed4) < prob
val loss = HDR.generate(trial, entityId, varId = entityId, seed3, seed4) * scale
// Result: Biased correlation between occurrence and loss

// GOOD: Independent streams
val occurrenceVarId = entityId.hashCode + 1000L
val lossVarId = entityId.hashCode + 2000L
val occurred = HDR.generate(trial, entityId, occurrenceVarId, seed3, seed4) < prob
val loss = HDR.generate(trial, entityId, lossVarId, seed3, seed4) * scale
```

### ❌ Mandatory Provenance in Domain Objects

```scala
// BAD: Provenance always required, no opt-out
case class RiskResult(
  outcomes: Map[TrialId, Loss],
  provenance: NodeProvenance  // Always present, even when not needed
)

// GOOD: Opt-in with Nil default, zero overhead when not requested
case class RiskResult(
  outcomes: Map[TrialId, Loss],
  provenances: List[NodeProvenance] = Nil  // Empty by default
)
```

### ❌ Incomplete Distribution Parameters

```scala
// BAD: Can't reconstruct distribution
case class MetalogParams(
  terms: Int  // Missing percentiles/quantiles
)

// GOOD: All parameters for reconstruction
case class MetalogParams(
  percentiles: Array[Double],
  quantiles: Array[Double],
  terms: Int,
  lowerBound: Option[Double],
  upperBound: Option[Double]
)
```

---

## Reproduction Workflow

1. **Extract provenance** from `RiskResult.provenances`
2. **For each `NodeProvenance`**, reconstruct the leaf's distribution
3. **Create `RiskSampler`** with exact HDR parameters from provenance
4. **Run simulation** with same `nTrials` (from `RiskResult.nTrials`)
5. **Verify**: Results match original within floating-point precision

---

## Implementation

| Component | Status |
|-----------|--------|
| HDR 4-layer hierarchy | ✅ Implemented |
| `NodeProvenance` | ✅ Implemented |
| `DistributionParams` sealed trait | ✅ Implemented |
| Optional provenance capture | ✅ Implemented (`includeProvenance` flag) |
| JSON serialization | ✅ Implemented |
| Global seeds from config | ✅ Implemented (`SimulationConfig.defaultSeed3/4`) |
| nTrials from config | ✅ Implemented (`SimulationConfig.defaultNTrials`) |
| Provenance in RiskResult | ✅ Implemented (`provenances: List[NodeProvenance]`) |

### Architectural Notes

- Provenance is embedded as `List[NodeProvenance]` in `RiskResult`
- This simplifies caching — provenance travels with the cached result
- `Identity[RiskResult].combine` accumulates provenances correctly during tree aggregation
- No separate tree-level provenance structure is needed; the flat list of per-node provenances is sufficient for reproduction

---

## References

- [HDR Paper](https://arxiv.org/abs/2004.06278) - Hash-based Deterministic Random
- simulation-util 0.8.0 - HDR implementation
- ADR-001: Validation Strategy (boundary patterns)
- ADR-015: RiskResultResolver (cache-aside pattern)
