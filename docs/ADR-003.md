# ADR-003: Provenance and Reproducibility

**Status:** Accepted  
**Date:** 2026-01-04  
**Tags:** provenance, reproducibility, hdr, monte-carlo, determinism

---

## Context

- Monte Carlo simulations must be **reproducible** for auditing and verification
- Random number generation needs **deterministic** behavior across runs
- Provenance data should enable **exact reproduction** of simulation results
- Zero overhead when provenance is not needed (opt-in feature)
- Distribution parameters must be **serializable** for later reconstruction

---

## Decision

### 1. HDR-Based 4-Layer Seed Hierarchy

Deterministic random number generation using HDR (Hash-based Deterministic Random) with 4-layer seed hierarchy:

```scala
// HDR seed hierarchy
HDR.generate(counter, entityId, varId, seed3, seed4)
             ↓        ↓        ↓      ↓      ↓
             trial    entity   variable global global

// Layer 1: Trial number (0..nTrials)
// Layer 2: Entity isolation (hash of riskId)
entityId = leaf.id.hashCode.toLong

// Layer 3: Variable isolation (occurrence vs loss)
occurrenceVarId = entityId.hashCode + 1000L
lossVarId = entityId.hashCode + 2000L

// Layer 4: Global seeds (user-controllable)
globalSeed3 = 0L  // Future: API parameter
globalSeed4 = 0L
```

**Why 4 layers:**
- **Trial isolation**: Same entity produces different values per trial
- **Entity isolation**: Different risks have independent random streams
- **Variable isolation**: Occurrence and loss sampling are uncorrelated
- **Global control**: User can change entire simulation outcome with one parameter

### 2. Optional Provenance Capture

Provenance is opt-in via `includeProvenance` flag, returned alongside results:

```scala
case class RiskTreeWithLEC(
  riskTree: RiskTree,
  quantiles: Map[String, Double],
  lecNode: Option[LECNode],
  provenance: Option[TreeProvenance] = None  // Opt-in
)

case class TreeProvenance(
  treeId: Long,
  globalSeeds: (Long, Long),
  nTrials: Int,
  nodeProvenances: Map[String, NodeProvenance]  // riskId → provenance
)
```

**Why optional:**
- Zero overhead when not needed
- Keeps response payloads small by default
- Provenance only for auditing/verification use cases

### 3. Distribution Parameters Storage

Store all parameters needed to reconstruct exact distribution:

```scala
sealed trait DistributionParams

case class MetalogParams(
  percentiles: Array[Double],   // [0.1, 0.5, 0.9]
  quantiles: Array[Double],     // [1000, 5000, 20000]
  terms: Int,                   // 3 or 9 terms
  lowerBound: Option[Double],   // Semi-bounded
  upperBound: Option[Double]
) extends DistributionParams

case class LognormalParams(
  minLoss: Long,                // P05 (90% CI lower)
  maxLoss: Long,                // P95 (90% CI upper)
  confidenceInterval: Double = 0.90
) extends DistributionParams
```

**Why capture both types:**
- Expert opinion (Metalog) needs percentiles + quantiles
- Lognormal needs confidence interval bounds
- Enables exact distribution reconstruction

### 4. Per-Node Provenance

Each risk node captures its own provenance independently:

```scala
case class NodeProvenance(
  // HDR Configuration
  riskId: String,
  entityId: Long,
  occurrenceVarId: Long,
  lossVarId: Long,
  globalSeed3: Long,
  globalSeed4: Long,
  
  // Distribution
  distributionType: String,
  distributionParams: DistributionParams,
  
  // Metadata
  timestamp: Instant,
  simulationUtilVersion: String
)
```

**Why per-node:**
- Each risk has independent random streams
- Portfolio aggregation doesn't need provenance (sum of children)
- Enables partial tree reproduction

---

## Code Smells

### ❌ Global Seed State

```scala
// BAD: Mutable global seed
object RandomState {
  var globalSeed: Long = 0L
  def nextRandom(): Double = { /* mutate state */ }
}

// GOOD: Pure HDR function
def sample(trial: Int, entityId: Long, varId: Long, seed3: Long, seed4: Long): Double =
  HDR.generate(trial, entityId, varId, seed3, seed4)
```

### ❌ Missing Variable Isolation

```scala
// BAD: Occurrence and loss share same varId
val occurred = HDR.generate(trial, entityId, varId = entityId, seed3, seed4) < prob
val loss = HDR.generate(trial, entityId, varId = entityId, seed3, seed4) * scale
// Result: Biased correlation between occurrence and loss

// GOOD: Independent streams
val occurrenceVarId = entityId.hashCode + 1000L
val lossVarId = entityId.hashCode + 2000L
val occurred = HDR.generate(trial, entityId, occurrenceVarId, seed3, seed4) < prob
val loss = HDR.generate(trial, entityId, lossVarId, seed3, seed4) * scale
```

### ❌ Embedding Provenance in Domain Objects

```scala
// BAD: Domain object couples to provenance
case class RiskResult(
  losses: Map[TrialId, Loss],
  provenance: NodeProvenance  // Always present, even when not needed
)

// GOOD: Provenance as separate companion
case class RiskResult(losses: Map[TrialId, Loss])

// Service returns tuple when provenance requested
def simulate(..., includeProvenance: Boolean): Task[(RiskResult, Option[NodeProvenance])]
```

### ❌ Incomplete Distribution Parameters

```scala
// BAD: Can't reconstruct distribution
case class MetalogParams(
  terms: Int  // Missing percentiles/quantiles
)

// GOOD: All parameters for reconstruction
case class MetalogParams(
  percentiles: Array[Double],
  quantiles: Array[Double],
  terms: Int,
  lowerBound: Option[Double],
  upperBound: Option[Double]
)
```

---

## Reproduction Workflow

1. **Extract provenance** from `RiskTreeWithLEC.provenance`
2. **For each risk node**, look up `NodeProvenance` by `riskId`
3. **Reconstruct distribution** from `distributionParams`
4. **Create `RiskSampler`** with exact HDR parameters
5. **Run `Simulator.simulateTree`** with same `nTrials`, `parallelism`
6. **Verify**: Results match original within floating-point precision

---

## Implementation

| Component | Status |
|-----------|--------|
| HDR 4-layer hierarchy | ✅ Implemented |
| `NodeProvenance` | ✅ Implemented |
| `TreeProvenance` | ✅ Implemented |
| `DistributionParams` sealed trait | ✅ Implemented |
| Optional provenance capture | ✅ Implemented |
| JSON serialization | ✅ Implemented |
| Global seeds API exposure | ⏳ Future (currently hardcoded to 0L) |

---

## References

- [HDR Paper](https://arxiv.org/abs/2004.06278) - Hash-based Deterministic Random
- simulation-util 0.8.0 - HDR implementation
- ADR-001: Validation Strategy (boundary patterns)
