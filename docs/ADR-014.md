# ADR-014: RiskResult Caching Strategy

**Status:** Accepted  
**Date:** 2026-01-18  
**Tags:** caching, LEC, RiskResult, performance, simulation

---

## Context

- LEC curves require **shared tick domains** for multi-curve Vega-Lite rendering
- Tick domain is computed at **render time** from all RiskResults being displayed
- HDR PRNG simulation is **cheap** (~1-5ms per node at 10K trials), but not for free
- We need outcomes (`RiskResult`) to compute exact exceedance at any loss tick
- Curve rendering is a **display concern**, not a caching concern

---

## Decision

### 1. Cache RiskResult (Simulation Outcomes)

Cache raw simulation outcomes, not rendered curves:

```scala
trait RiskResultCache {
  def get(nodeId: NodeId): UIO[Option[RiskResult]]
  def set(nodeId: NodeId, result: RiskResult): UIO[Unit]
  def remove(nodeId: NodeId): UIO[Unit]
  def invalidate(nodeId: NodeId): UIO[List[NodeId]]  // O(depth) via TreeIndex
  def clear: UIO[Unit]
}
```

**Why cache outcomes, not curves:**
- Curves depend on **what nodes are displayed together** (shared tick domain)
- Cannot cache "the" LEC for a node independently—it depends on display context
- Outcomes enable exact `P(Loss >= x)` at any tick via `RiskResult.probOfExceedance`

### 2. Compute Shared Tick Domain at Render Time

When rendering multiple curves:

```scala
def generateCurvePointsMulti(
  results: Map[NodeId, RiskResult],
  nEntries: Int = 100
): Map[NodeId, Vector[(Long, Double)]] = {
  
  // 1. Combined range from ALL results
  val combinedMin = results.values.map(_.minLoss).min
  val combinedMax = results.values.map(_.maxLoss).max
  
  // 2. Shared ticks for all curves
  val sharedTicks = getTicks(combinedMin, combinedMax, nEntries)
  
  // 3. Compute exceedance at shared ticks for EACH result
  results.map { case (nodeId, result) =>
    val points = sharedTicks.map { loss =>
      (loss, result.probOfExceedance(loss).toDouble)
    }
    nodeId -> points
  }
}
```

### 3. Invalidation on Node Change

Uses `TreeIndex` to invalidate O(depth) ancestor entries:

```scala
// Node parameter changed → invalidate node + ancestors
RiskResultCache.invalidate(nodeId)
// Returns: List[NodeId] = [root, ..., parent, nodeId]
```

---

## Code Smells

### ❌ Caching Rendered Curves

```scala
// BAD: Cache rendered (loss, prob) points — tick domain is display-context dependent
cache.put(nodeId, generateCurvePoints(result, nTicks = 100))
// Later: need different tick range for multi-node view → cache miss or interpolation errors

// GOOD: Cache RiskResult outcomes, render curves on demand
cache.put(nodeId, result)  // raw outcomes
LECGenerator.generateCurvePointsMulti(results, nTicks)  // shared ticks at render time
```

### ❌ Full-Tree Invalidation on Single-Node Change

```scala
// BAD: Clear entire tree cache when one node changes
def onNodeChanged(treeId: TreeId): UIO[Unit] =
  cacheManager.onTreeStructureChanged(treeId)  // O(n) — clears everything

// GOOD: Invalidate only the ancestor path — O(depth)
def onNodeChanged(treeId: TreeId, nodeId: NodeId): UIO[Unit] =
  cacheManager.invalidate(tree, nodeId)  // clears node + ancestors, preserves siblings
```

### ❌ Simulation Inside Query Methods

```scala
// BAD: Each query method re-simulates
def getLEC(nodeId: NodeId) = simulateSubtree(nodeId).map(generateCurvePoints)
def getProb(nodeId: NodeId, t: Loss) = simulateSubtree(nodeId).map(_.probOfExceedance(t))

// GOOD: Cache-aside via RiskResultResolver, query methods are pure transforms
def getLEC(nodeId: NodeId) = resolver.ensureCached(tree, nodeId).map(generateCurvePoints)
def getProb(nodeId: NodeId, t: Loss) = resolver.ensureCached(tree, nodeId).map(_.probOfExceedance(t))
```

---

## Architecture

```
┌─────────────────────────────────────────────────────────────────┐
│                         RiskResultCache                          │
│  Map[NodeId, RiskResult]                                         │
│  - Cache raw simulation outcomes                                 │
│  - Invalidation: clear node + ancestors via TreeIndex            │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│                   LECGenerator (render-time)                     │
│  generateCurvePointsMulti(results, nTicks)                       │
│                                                                  │
│  1. Compute combined loss range from all RiskResults             │
│  2. Generate shared evenly-spaced ticks                          │
│  3. For each node: compute P(Loss >= tick) at each tick          │
│  4. Bundle with metadata for Vega-Lite                           │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│                      LECResponse (API DTO)                       │
│  List[LECCurve] with id, name, color, (loss, prob) points        │
└─────────────────────────────────────────────────────────────────┘
```

---

## Trade-offs

| Aspect | Value |
|--------|-------|
| Memory | ~80KB/node (10K trials × 8 bytes) |
| Flexibility | Any tick domain at render time |
| Accuracy | Exact exceedance computation |
| Complexity | Simple cache-aside pattern |

**Memory is acceptable** because:
- 10K trials × 8 bytes × 100 nodes = 8MB (manageable)
- Enables exact exceedance computation at any tick
- No interpolation = no mathematical errors

---

## Implementation

| Location | Pattern |
|----------|---------|
| `services/cache/RiskResultCache.scala` | Cache trait + Ref-based impl |
| `simulation/LECGenerator.scala` | `generateCurvePointsMulti` |
| `services/RiskTreeServiceLive.scala` | Cache-aside pattern |
| `domain/tree/TreeIndex.scala` | O(depth) ancestor lookup |

---

## Service Layer Integration

See **[ADR-015.md](./ADR-015.md)** for the service layer that builds on this cache:

- **`RiskResultResolver`**: Service with `ensureCached(tree, nodeId)` primitive
- **Query APIs as compositions**: `resolver.ensureCached(tree, nodeId).map(transform)`
- **Cache as source of truth**: Simulation results are cached per node, queried directly

---

## References

- [ADR-014-appendix.md](./ADR-014-appendix.md) — Analysis of caching options
- [ADR-014-appendix-b.md](./ADR-014-appendix-b.md) — Cache invalidation & request flow diagrams
- [ADR-009.md](./ADR-009.md) — RiskResult Identity for outcome aggregation
- [ADR-015.md](./ADR-015.md) — Cache Integration: RiskResultResolver pattern
