# ADR-012: Service Mesh Strategy

**Status:** Accepted (awaiting implementation)  
**Date:** 2026-01-17  
**Tags:** infrastructure, service-mesh, resilience, authentication, authorization

---

## Context

- **Resilience** (retries, circuit breaking, timeouts) should be handled at infrastructure level, not application code
- **Authentication/Authorization** should be externalized to dedicated services (Keycloak, OPA)
- Service mesh provides **uniform policy enforcement** across all services
- Application code should focus on **business logic**, not infrastructure concerns
- Development environment can **let failures happen** (no mesh required locally)

---

## Decision

### 1. Istio Ambient Mode as Service Mesh

Istio Ambient Mode is the chosen service mesh implementation:

- **ztunnel** — L4 proxy for mTLS between all pods (zero-config, low overhead)
- **Waypoint proxies** — L7 features (JWT validation, routing, authorization) deployed per-namespace

**Rationale:**
- Native JWT/OIDC validation via `RequestAuthentication`
- First-class OPA integration via `ext_authz` filter
- Lower resource usage than sidecar mode
- CNCF Graduated project with strong ecosystem

### 2. Keycloak for Identity (OAuth2/OIDC)

Keycloak provides:
- User authentication (login flows)
- JWT token issuance
- Role management and JWT claims mapping
- JWKS endpoint for mesh JWT validation

### 3. OPA for Authorization

Open Policy Agent (OPA) provides:
- Rego-based authorization policies
- Integration via Istio `ext_authz`
- Centralized policy management
- Audit logging of authorization decisions

### 4. No Application-Level Resilience Code

The following are **delegated to Istio**, not implemented in Scala:
- Retries (via `VirtualService`)
- Circuit breaking (via `DestinationRule.outlierDetection`)
- Timeouts (via `VirtualService`)
- Rate limiting (via EnvoyFilter or waypoint config)

### 5. Minimal Service Code for Auth

Service code handles only:
- JWT claims parsing (mesh validates, app extracts `UserContext`)
- Data-level authorization ("can user X access resource Y?")
- Audit logging (structured logging of actions)

**Estimated:** ~100-200 lines across entire backend.

---

## Architecture

```
┌─────────────────────────────────────────────────────────────────────────┐
│                              Request Flow                                │
└─────────────────────────────────────────────────────────────────────────┘

  Browser → Keycloak (login) → JWT
     │
     ▼
┌─────────┐     ┌─────────────────┐     ┌─────────────────┐
│ Ingress │────▶│ JWT Validation  │────▶│   OPA Authz     │
│ Gateway │     │ (Istio/Waypoint)│     │   (ext_authz)   │
└─────────┘     └─────────────────┘     └────────┬────────┘
                                                  │
                                                  ▼
┌─────────────────────────────────────────────────────────────────────────┐
│                         Service Mesh Data Plane                          │
│  ┌──────────────┐    ┌──────────────┐    ┌──────────────┐               │
│  │ ZIO Backend  │───▶│    Irmin     │───▶│  PostgreSQL  │               │
│  │  (ztunnel)   │    │  (ztunnel)   │    │  (ztunnel)   │               │
│  └──────────────┘    └──────────────┘    └──────────────┘               │
│         │                   │                   │                        │
│         └───────── mTLS ────┴───── mTLS ────────┘                        │
└─────────────────────────────────────────────────────────────────────────┘
```

For detailed OAuth2 flow diagrams and sequences, see: [OAUTH2-FLOW-ARCHITECTURE.md](./OAUTH2-FLOW-ARCHITECTURE.md)

---

## Code Smells

### ❌ Application-Level Circuit Breaker

```scala
// BAD: Resilience in application code
val circuitBreaker = CircuitBreaker.make(...)
circuitBreaker.protect(irminClient.query(...))
```

```scala
// GOOD: Let Istio handle it
irminClient.query(...)  // Mesh provides retries/circuit breaking
```

### ❌ Manual JWT Validation

```scala
// BAD: Validating JWT in application
def validateJwt(token: String): IO[AuthError, Claims] =
  for {
    key   <- fetchJwksKey(...)
    claims <- verifySignature(token, key)
    _     <- checkExpiry(claims)
  } yield claims
```

```scala
// GOOD: Trust mesh validation, parse claims only
def extractUserContext(headers: Headers): IO[AuthError, UserContext] =
  // Mesh already validated; just parse forwarded claims
  parseClaimsFromHeader(headers.get("x-jwt-claims"))
```

---

## Development Environment

**Decision:** Let it fail (no service mesh locally)

- Docker Compose runs services directly (no sidecars)
- No JWT validation locally (trust all requests or use mock)
- Failures are acceptable during development
- Integration testing with mesh happens in staging/CI

---

## Implementation Guidance

For JWT claims parsing and UserContext extraction, consult Keycloak documentation and Istio RequestAuthentication examples directly.

**Before implementing:**
1. Review Keycloak OIDC and Istio JWT forwarding documentation
2. Validate applicability against current codebase state
3. Adapt patterns to project conventions (ADR-010, ADR-011)

**Note:** The Cheleb reference architecture is relevant for ZIO + PostgreSQL layer patterns (see Tier 1.5), but does **not** contain Keycloak or OAuth2 integration patterns.

Do **not** reinvent established patterns—leverage proven implementations first.

---

## Consequences

**Positive:**
- Consistent resilience across all services (mesh-enforced)
- Centralized auth policy (Keycloak + OPA)
- Reduced application code complexity
- Zero-trust security model (mTLS everywhere)

**Negative:**
- Mesh adds operational complexity
- Debugging requires mesh observability tools
- Local dev differs from production (no mesh)

**Neutral:**
- Team must learn Istio concepts
- Staging environment must mirror production mesh config

---

## References

- [OAUTH2-FLOW-ARCHITECTURE.md](./OAUTH2-FLOW-ARCHITECTURE.md) — Detailed OAuth2 flow diagrams
- [ADR-021: Capability URLs](./ADR-021-capability-urls.md) — Unauthenticated demo access via capability tokens (requires mesh policy exception for `/demo/*`)
- Istio Ambient Mode: https://istio.io/latest/docs/ambient/
- Keycloak: https://www.keycloak.org/
- OPA + Istio: https://www.openpolicyagent.org/docs/latest/envoy-introduction/
- Cheleb Reference Architecture: (consult for ZIO + PostgreSQL layer patterns only — not OAuth2)
