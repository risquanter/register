# ADR-010: Error Handling Strategy

**Status:** Accepted  
**Date:** 2026-01-17  
**Tags:** errors, validation, zio, functional-programming

---

## Context

- Errors are **values**, not exceptions—use typed error channels
- Validation errors **accumulate**—don't fail fast on first error
- HTTP boundary maps **typed errors to status codes**—no string matching
- Domain errors are **machine-readable**—typed codes for client handling
- Service layer **logs before boundary**—pure encoding at HTTP edge

---

## Decision

### 1. Sealed Error Hierarchy

All domain errors extend `SimulationError` sealed trait:

```scala
sealed trait SimulationError extends Throwable

case class ValidationFailed(errors: List[ValidationError]) extends SimulationError
case class RepositoryFailure(reason: String) extends SimulationError
case class SimulationFailure(simulationId: String, cause: Throwable) extends SimulationError
case class DataConflict(reason: String) extends SimulationError
```

### 2. Typed Validation Errors

Validation errors carry structured information with typed codes:

```scala
case class ValidationError(
  field: String,              // JSON path: "root.children[0].minLoss"
  code: ValidationErrorCode,  // Machine-readable: INVALID_RANGE
  message: String             // Human-readable: "minLoss must be < maxLoss"
)

enum ValidationErrorCode:
  case REQUIRED_FIELD, INVALID_FORMAT, INVALID_RANGE, INVALID_LENGTH
  case INVALID_PATTERN, CONSTRAINT_VIOLATION, INVALID_COMBINATION
  // ... domain-specific codes
```

### 3. ZIO Prelude Validation for Accumulation

Smart constructors return `Validation[ValidationError, A]` to collect all errors:

```scala
def create(...): Validation[ValidationError, RiskLeaf] = {
  val idV = refineId(id, "root.id")
  val nameV = refineName(name, "root.name")
  val probV = refineProbability(prob, "root.probability")
  
  Validation.validateWith(idV, nameV, probV) { (id, name, prob) =>
    RiskLeaf(id, name, prob, ...)
  }
}
```

### 4. Hybrid Error Channel Strategy

**Domain layer** uses typed errors for compile-time safety:
```scala
def create(...): Validation[ValidationError, RiskLeaf]  // Typed, accumulates
```

**Service layer** uses `Task[A]` with sealed hierarchy for composition:
```scala
trait RiskTreeService {
  def create(req: RiskTreeDefinitionRequest): Task[RiskTree]
  def computeLEC(id: NonNegativeLong, ...): Task[RiskTreeWithLEC]
}
```

**HTTP boundary** recovers type safety via pattern matching on sealed trait.

#### Why `Task[A]` over `IO[SimulationError, A]` at Service Layer

| `Task[A]` (Chosen) | `IO[SimulationError, A]` (Alternative) |
|--------------------|----------------------------------------|
| ✅ Simpler composition with ZIO libs | ❌ Requires `.mapError` to combine |
| ✅ No error widening ceremony | ❌ Must define common supertypes |
| ✅ ZIO ecosystem convention | ❌ Viral changes when adding errors |
| ❌ Errors not in signature | ✅ Self-documenting signatures |
| ❌ Runtime error discovery | ✅ Compile-time exhaustiveness |

**Tradeoff:** We accept weaker signature-level documentation in exchange for simpler ZIO composition.
Type safety is recovered at HTTP boundary via sealed `SimulationError` pattern matching.

### 5. Pure HTTP Error Mapping

`ErrorResponse.encode` uses pattern matching on sealed hierarchy—no string parsing:

```scala
def encode(error: Throwable): (StatusCode, ErrorResponse) = error match {
  case ValidationFailed(errors)     => makeValidationResponse(errors)      // 400
  case RepositoryFailure(reason)    => makeRepositoryFailureResponse(reason) // 500
  case SimulationFailure(id, cause) => makeSimulationFailureResponse(id)   // 500
  case DataConflict(reason)         => makeDataConflictResponse(reason)    // 409
  case _                            => makeGeneralResponse()               // 500
}
```

---

## Code Smells

### ❌ Throwing Exceptions

```scala
// BAD: Throw exception
def validate(value: Int): Int =
  if value < 0 then throw new IllegalArgumentException("must be positive")
  else value

// GOOD: Return error in type
def validate(value: Int): Validation[ValidationError, PositiveInt] =
  refinePositiveInt(value, "field")
```

### ❌ Fail-Fast Validation

```scala
// BAD: Stop at first error
for {
  id   <- refineId(rawId).toZIO
  name <- refineName(rawName).toZIO  // Never runs if id fails
} yield (id, name)

// GOOD: Accumulate all errors
Validation.validateWith(refineId(rawId), refineName(rawName)) { (id, name) =>
  (id, name)  // Reports both errors if both fail
}
```

### ❌ String Matching on Errors

```scala
// BAD: Parse error messages
def encode(error: Throwable) = error.getMessage match {
  case msg if msg.contains("validation") => (400, ...)
  case msg if msg.contains("conflict")   => (409, ...)
}

// GOOD: Pattern match on types
def encode(error: Throwable) = error match {
  case ValidationFailed(_) => (StatusCode.BadRequest, ...)
  case DataConflict(_)     => (StatusCode.Conflict, ...)
}
```

### ❌ Untyped Error Codes

```scala
// BAD: String error codes
case class ValidationError(field: String, code: String, message: String)
// code = "invalid" — what does this mean?

// GOOD: Typed enum codes
case class ValidationError(field: String, code: ValidationErrorCode, message: String)
// code = ValidationErrorCode.INVALID_RANGE — machine-readable
```

### ❌ Logging at HTTP Boundary

```scala
// BAD: Log in pure encoder (outside ZIO runtime)
def encode(error: Throwable) = {
  logger.error(s"Error: $error")  // Side effect in pure function!
  (StatusCode.InternalServerError, ...)
}

// GOOD: Log at service layer before boundary
def serviceMethod = 
  businessLogic
    .tapErrorCause(cause => ZIO.logErrorCause("Operation failed", cause))
// ErrorResponse.encode is pure—logging already done
```

---

## Implementation

| Location | Pattern |
|----------|---------|
| `domain/errors/SimulationError.scala` | Sealed error hierarchy + `ValidationError` |
| `domain/errors/ValidationErrorCode.scala` | Typed error code enum (15 cases) |
| `domain/errors/ErrorResponse.scala` | `encode()` typed pattern matching to HTTP |
| `domain/errors/ErrorDetail.scala` | API response with field path, code, requestId |
| `domain/data/iron/ValidationUtil.scala` | Refinement returning `Validation[E, A]` |
| `domain/data/RiskNode.scala` | `RiskLeaf.create` smart constructor with accumulation |

---

## References

- ADR-001: Validation with Iron types & smart constructors
- ADR-002: Logging strategy (service layer, not boundary)
- ZIO Prelude Validation: https://zio.dev/zio-prelude/functional-abstractions/validation/
