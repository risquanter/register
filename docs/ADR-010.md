# ADR-010: Error Handling Strategy

**Status:** Accepted  
**Date:** 2026-01-17  
**Tags:** errors, validation, zio, functional-programming

---

## Context

- Errors are **values**, not exceptions—use typed error channels
- Validation errors **accumulate**—don't fail fast on first error
- HTTP boundary maps **typed errors to status codes**—no string matching
- Domain errors are **machine-readable**—typed codes for client handling
- Service layer **logs before boundary**—pure encoding at HTTP edge

---

## Decision

### 1. Sealed Error Hierarchy

All domain errors extend \`SimulationError\` sealed trait:

\`\`\`scala
sealed trait SimulationError extends Throwable

case class ValidationFailed(errors: List[ValidationError]) extends SimulationError
case class RepositoryFailure(reason: String) extends SimulationError
case class SimulationFailure(simulationId: String, cause: Throwable) extends SimulationError
case class DataConflict(reason: String) extends SimulationError
\`\`\`

### 2. Typed Validation Errors

Validation errors carry structured information with typed codes:

\`\`\`scala
case class ValidationError(
  field: String,              // JSON path: "root.children[0].minLoss"
  code: ValidationErrorCode,  // Machine-readable: INVALID_RANGE
  message: String             // Human-readable: "minLoss must be < maxLoss"
)

enum ValidationErrorCode:
  case REQUIRED_FIELD, INVALID_FORMAT, INVALID_RANGE, INVALID_LENGTH
  case INVALID_PATTERN, CONSTRAINT_VIOLATION, INVALID_COMBINATION
\`\`\`

### 3. ZIO Prelude Validation for Accumulation

Smart constructors return \`Validation[ValidationError, A]\` to collect all errors:

\`\`\`scala
def create(...): Validation[ValidationError, RiskLeaf] = {
  val idV = refineId(id, "root.id")
  val nameV = refineName(name, "root.name")
  val probV = refineProbability(prob, "root.probability")
  
  Validation.validateWith(idV, nameV, probV) { (id, name, prob) =>
    RiskLeaf(id, name, prob, ...)
  }
}
\`\`\`

### 4. Hybrid Error Channel Strategy

**Domain layer:** \`Validation[ValidationError, A]\` (typed, accumulates)  
**Service layer:** \`Task[A]\` with sealed hierarchy (simpler composition)  
**HTTP boundary:** Pattern match on \`SimulationError\` (recovers type safety)

\`\`\`scala
trait RiskTreeService {
  def create(req: RiskTreeDefinitionRequest): Task[RiskTree]
  def computeLEC(id: NonNegativeLong, ...): Task[RiskTreeWithLEC]
}
\`\`\`

**Tradeoff:** We accept weaker signature-level documentation in exchange for simpler ZIO composition. Type safety recovered at HTTP boundary via sealed trait pattern matching.

### 5. Pure HTTP Error Mapping

\`ErrorResponse.encode\` uses pattern matching—no string parsing:

\`\`\`scala
def encode(error: Throwable): (StatusCode, ErrorResponse) = error match {
  case ValidationFailed(errors)     => makeValidationResponse(errors)      // 400
  case RepositoryFailure(reason)    => makeRepositoryFailureResponse(reason) // 500
  case SimulationFailure(id, cause) => makeSimulationFailureResponse(id)   // 500
  case DataConflict(reason)         => makeDataConflictResponse(reason)    // 409
  case _                            => makeGeneralResponse()               // 500
}
\`\`\`

---

## Exceptions: Acceptable Uses of \`require()\`

While errors should be values, \`require()\` is acceptable as **defense-in-depth** for invariants:

### 1. Case Class Constructor Invariants

Private constructor + smart constructor + \`require()\` safety net:

\`\`\`scala
final case class RiskPortfolio private (
  safeId: SafeId.SafeId,
  safeName: SafeName.SafeName,
  children: Array[RiskNode]
) extends RiskNode {
  // Safety net: Should never trigger if validation works
  require(children.nonEmpty, "RiskPortfolio invariant violated")
}

object RiskPortfolio {
  def create(...): Validation[ValidationError, RiskPortfolio] = {
    val childrenV = if children.nonEmpty then Validation.succeed(children)
                    else Validation.fail(ValidationError.invalidField(...))
    Validation.validateWith(idV, nameV, childrenV) { (id, name, ch) =>
      new RiskPortfolio(id, name, ch)  // Private constructor
    }
  }
}
\`\`\`

**When acceptable:**
- ✅ Smart constructor with \`Validation\` enforces all entry points
- ✅ Constructor is \`private\` (prevents direct instantiation)
- ✅ JSON deserialization uses custom decoders calling smart constructors
- ✅ No reflection bypasses exist

**Purpose:** Catch programmer errors (bugs), not user input errors.

### 2. External Library Preconditions

Protecting against invalid operations in third-party libraries:

\`\`\`scala
case class LognormalDistribution(meanLog: Double, stdLog: Double) {
  require(stdLog > 0, s"stdLog must be positive, got: $stdLog")
  private val underlying = new LogNormalDistribution(meanLog, stdLog)  // Apache Commons Math
}
\`\`\`

### 3. Internal Method Preconditions

Assertions on parameters controlled by validated domain objects:

\`\`\`scala
private def getTicks(minLoss: Long, maxLoss: Long, nEntries: Int): Vector[Long] = {
  require(nEntries > 1, "nEntries must be > 1")
  require(minLoss >= 0, "minLoss must be >= 0")
  require(maxLoss >= minLoss, "maxLoss must be >= minLoss")
  // Parameters derived from validated RiskResult
}
\`\`\`

**Note:** Public API methods still use \`Validation[E, A]\` for user input.

---

## Code Smells

### ❌ Throwing Exceptions

\`\`\`scala
// BAD: Throw exception
def validate(value: Int): Int =
  if value < 0 then throw new IllegalArgumentException("must be positive")
  else value

// GOOD: Return error in type
def validate(value: Int): Validation[ValidationError, PositiveInt] =
  refinePositiveInt(value, "field")
\`\`\`

### ❌ Fail-Fast Validation

\`\`\`scala
// BAD: Stop at first error
for {
  id   <- refineId(rawId).toZIO
  name <- refineName(rawName).toZIO  // Never runs if id fails
} yield (id, name)

// GOOD: Accumulate all errors
Validation.validateWith(refineId(rawId), refineName(rawName)) { (id, name) =>
  (id, name)  // Reports both errors if both fail
}
\`\`\`

### ❌ String Matching on Errors

\`\`\`scala
// BAD: Parse error messages
def encode(error: Throwable) = error.getMessage match {
  case msg if msg.contains("validation") => (400, ...)
}

// GOOD: Pattern match on types
def encode(error: Throwable) = error match {
  case ValidationFailed(_) => (StatusCode.BadRequest, ...)
}
\`\`\`

### ❌ Untyped Error Codes

\`\`\`scala
// BAD: String error codes
case class ValidationError(field: String, code: String, message: String)

// GOOD: Typed enum codes
case class ValidationError(field: String, code: ValidationErrorCode, message: String)
\`\`\`

### ❌ Logging at HTTP Boundary

\`\`\`scala
// BAD: Log in pure encoder
def encode(error: Throwable) = {
  logger.error(s"Error: $error")  // Side effect in pure function!
  (StatusCode.InternalServerError, ...)
}

// GOOD: Log at service layer before boundary
def serviceMethod = 
  businessLogic.tapErrorCause(cause => ZIO.logErrorCause("Failed", cause))
\`\`\`

---

## Implementation

| Location | Pattern |
|----------|---------|
| \`domain/errors/SimulationError.scala\` | Sealed error hierarchy + \`ValidationError\` |
| \`domain/errors/ValidationErrorCode.scala\` | Typed error code enum (15 cases) |
| \`domain/errors/ErrorResponse.scala\` | \`encode()\` typed pattern matching to HTTP |
| \`domain/data/iron/ValidationUtil.scala\` | Refinement returning \`Validation[E, A]\` |
| \`domain/data/RiskNode.scala\` | Smart constructors with accumulation |

---

## References

- ADR-001: Validation with Iron types & smart constructors
- ADR-002: Logging strategy (service layer, not boundary)
- ZIO Prelude Validation: https://zio.dev/zio-prelude/functional-abstractions/validation/
