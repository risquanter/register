# ADR-002: Logging Strategy

**Status:** Accepted  
**Date:** 2026-01-12  
**Tags:** logging, telemetry, observability, zio

---

## Context

- OpenTelemetry already provides **request tracing** (spans) and **business metrics**
- ZIO's built-in logging outputs structured logs to console
- Third-party library logging (SLF4J) currently routes through Logback
- Debug hacks using `System.err.println` exist in error handling code
- No `logback.xml` configuration—relying on defaults

---

## Decision

### 1. Telemetry for Tracing and Metrics, Logging for Diagnostics

OpenTelemetry handles **what happened** (spans, metrics). Logging handles **why it failed** (errors, debug).

| Use Case | Tool |
|----------|------|
| Request flow tracing | OpenTelemetry Spans |
| Business metrics (counters, histograms) | OpenTelemetry Metrics |
| Error diagnostics with stack traces | `ZIO.logError` |
| Development debugging | `ZIO.logDebug` |
| Audit trail | `ZIO.logInfo` |

```scala
// GOOD: Use telemetry for tracing
tracing.span("computeLEC") {
  // Use logging for errors
  effect.tapError(e => ZIO.logErrorCause("Simulation failed", Cause.fail(e)))
}
```

### 2. Defer SLF4J Bridge Integration

**Rationale:** This codebase has minimal third-party libraries that produce meaningful logs:
- OpenTelemetry SDK (internal diagnostics only)
- Netty via ZIO HTTP (connection errors)
- simulation.util (silent)

The SLF4J bridge (`zio-logging-slf4j2-bridge`) would unify log formats and enable trace correlation in third-party logs, but adds complexity for marginal benefit given our limited external log sources.

**Decision:** Do not add the bridge now. Revisit if:
- Adding database driver (e.g., Quill/Postgres) with verbose logging
- Adding HTTP client libraries with request logging
- Trace correlation in third-party logs becomes a debugging requirement

```scala
// CURRENT: Third-party logs go through Logback (different format)
// ACCEPTABLE: Few third-party log sources in this codebase
// FUTURE: Add zio-logging-slf4j2-bridge if third-party logging increases
```

### 3. Configure Log Levels via logback.xml

Add explicit log level configuration for environment-appropriate verbosity:

```xml
<!-- modules/server/src/main/resources/logback.xml -->
<configuration>
  <appender name="STDOUT" class="ch.qos.logback.core.ConsoleAppender">
    <encoder>
      <pattern>%d{ISO8601} %-5level [%thread] %logger{36} - %msg%n</pattern>
    </encoder>
  </appender>
  
  <!-- Application: DEBUG in dev, INFO in prod (via env override) -->
  <logger name="com.risquanter" level="${LOG_LEVEL:-INFO}"/>
  
  <!-- Quiet third-party noise -->
  <logger name="io.netty" level="WARN"/>
  <logger name="io.opentelemetry" level="WARN"/>
  
  <root level="INFO">
    <appender-ref ref="STDOUT"/>
  </root>
</configuration>
```

### 4. Replace Debug Hacks with Proper Logging

Remove `System.err.println` and use ZIO logging with Cause for stack traces:

```scala
// BAD: Debug hack
System.err.println(s"[ERROR] Simulation failed:")
error.printStackTrace(System.err)

// GOOD: Proper logging with cause
ZIO.logErrorCause(s"Simulation failed for $simulationId", Cause.fail(error))
```

### 5. Use Typed Error Hierarchy for Domain Errors

**Rationale:** String matching on error messages is fragile. ZIO's type system enables expressing error boundaries cleanly through a sealed trait hierarchy.

**Decision:** All domain errors extend `SimulationError` sealed trait. Each error type:
- Has a single logging point at its origin (if needed)
- Propagates type-safely to HTTP boundary
- Is pattern-matched without string inspection

```scala
// ERROR HIERARCHY: Typed, exhaustive matching
sealed trait SimulationError extends Throwable
case class ValidationFailed(errors: List[ValidationError]) extends SimulationError
case class RepositoryFailure(reason: String) extends SimulationError  
case class SimulationFailure(simulationId: String, cause: Throwable) extends SimulationError
case class DataConflict(reason: String) extends SimulationError

// SERVICE LAYER: Log and wrap in typed error
def runTreeSimulation(...): Task[...] =
  Simulator.simulateTree(...)
    .tapErrorCause(cause => ZIO.logErrorCause("Simulation failed", cause))
    .mapError(error => SimulationFailure(simulationId, error))

// HTTP BOUNDARY: Pure typed pattern matching, no string inspection
def encode(error: Throwable): (StatusCode, ErrorResponse) = error match {
  case ValidationFailed(errors)     => makeValidationResponse(errors)
  case RepositoryFailure(reason)    => makeRepositoryFailureResponse(reason)
  case SimulationFailure(id, cause) => makeSimulationFailureResponse(id)
  case DataConflict(reason)         => makeDataConflictResponse(reason)
  case _ => makeGeneralResponse()  // Truly unexpected
}
```

**Benefits:**
- Compiler-checked exhaustiveness for error handling
- No fragile string matching
- Single logging point per error type (at origin)
- HTTP boundary remains pure
- Easy to add new error types

---

## Code Smells

### ❌ Using System.err for Error Logging

```scala
// BAD: Bypasses logging infrastructure
catch { case e: Exception =>
  System.err.println(s"[ERROR] $e")
  e.printStackTrace()
}

// GOOD: Uses ZIO logging with full cause
.tapError(e => ZIO.logErrorCause("Operation failed", Cause.fail(e)))
```

### ❌ Logging Instead of Telemetry for Request Tracing

```scala
// BAD: Using logs for tracing
ZIO.logInfo(s"Starting computeLEC for id=$id")
// ... operation
ZIO.logInfo(s"Completed computeLEC in ${duration}ms")

// GOOD: Using spans for tracing
tracing.span("computeLEC", SpanKind.INTERNAL) {
  tracing.setAttribute("risk_tree.id", id) *> operation
}
```

### ❌ Missing Log Level Differentiation

```scala
// BAD: Everything at INFO
ZIO.logInfo(s"Processing request")
ZIO.logInfo(s"Cache hit for key=$key")
ZIO.logInfo(s"Validation failed: $errors")

// GOOD: Appropriate levels
ZIO.logDebug(s"Processing request")      // Development only
ZIO.logDebug(s"Cache hit for key=$key")  // Performance debugging
ZIO.logWarning(s"Validation failed: $errors")  // Recoverable issues
```

---

## Implementation

| Location | Change |
|----------|--------|
| `SimulationError.scala` | Add `SimulationFailure`, `DataConflict` to typed error hierarchy |
| `ErrorResponse.scala` | Use typed pattern matching (no string inspection) |
| `SimulationExecutionService.scala` | Log errors, wrap in `SimulationFailure` |
| `RiskTreeServiceLive.scala` | Match on `SimulationError` hierarchy in `logIfUnexpected` |
| `logback.xml` | Log level configuration |

---

## References

- [ZIO Logging Documentation](https://zio.dev/zio-logging/)
- [OpenTelemetry Signals](https://opentelemetry.io/docs/concepts/signals/)
- ADR-001: Validation Strategy (boundary patterns)
